Silver-Phoenix
Mathematical Computations and Derivations for Silver-Phoenix - Physics Modelling Archive

"If you wish to make an apple pie from scratch, you must first invent the universe." - Carl Sagan

First, the logic gate: 0+x=1. I choose this because it is the dead minimum of data for a logic gate I could think of. 0 is OFF, FALSE, or NO (and also represents initial conditions). 1 is ON, TRUE, or YES (and represents a new condition). x is self referential and contains no other external data. It represents ONLY a reference to the logic gate, itself. As an equation, this logic gate can be understood as: Origin plus logic gate = new origin parameter.

From this, we build the universe.

Our initial environment: Absolute void. Not 'nothing' because that implies the lack of 'something'. True and absolute void.

Into this void, we will place our singular piece of data. The Logic Gate.

Into the void, the logic gate begins it's cycle from origin state. x sees that the logic gate exists, the gate returns "1". For our purposes, I will use YES, but 1, True, On, or any positive binary term will work.

In the void, a YES now exists. There are no other data in the void to give definition to this point. It is all potential points while being none. We have created infinite POTENTIAL and an absolute value of YES. The gate cycles back to zero. The origin state is POTENTIAL, and the gate fires FROM DIMENSION 0 (d0).

To return a new YES, the gate cannot create a new point within POTENTIAL. If it does, the origin state does not change. It must return YES in a new place. Outside of POTENTIAL.

A second YES appears within the universe, not POTENTIAL, but REAL as it has definition in it's relationship to the first point of YES. The moment the second point is created, the FIRST point also becomes real as it's relationship to the second point is defined. All points between the two points propagate into REAL points. All points on the axis not contained within the two points have a relationship to the DEFINITE VALUE, but are NO and extend to infinity. We have created an INFINITE LINE and DISTANCE. The FIRST DIMENSION. The gate cycles back to 0. The gate fires again.

A third point, not contained within the infinite object returns a new YES that is separate. Three points exist and all points between them propagate into existence. All points external to the connection now have relational data, but are NO. We have created an INIFINITE PLANE and an DEFINITE VALUE of Area. The Second Dimension (2d). The gate fires again.

A fourth point, outside of the infinite plane is created. We have INFINITE SPACE and DEFINITE VOLUME. The gate fires again.

To this point, every dimension is comprised of an infinite stack of previous dimensions and is an infinitely thin slice of the next. The new point is outside of SPACE, an infinite stack of the previous dimension. This is a sequence of spatial snapshots. Time. The FOURTH DIMENSION. The Gate fires again.

Where does it fire the new point? Special Relativity states that there are four dimensions: 3 of space and 1 of time. In this thought experiment we have ONLY space and time. No gravity. No matter. No energy. We must have another dimension, but what? We find our clue in the FIRST DIMENSION. The mathematics are linear for the FIRST and FOURTH dimensions (distance and duration). This is a system built on logic, propagation, and recursion. There are three dimensions of space. Could there be three dimensions of time? 1D is to 4d what 2d is to 5d. What is 5th dimensional time?

Your time and mine are different. As you fly on airplanes or drive through valleys below sea level, your center of mass in relation to the Earth's center of mass changes and dilation/expansion give your timeline a uniqueness compared to mine. But as we sit here together, our threads overlap. The threads of everyone you know, everyone near you weaves together to form a sheet of time. For all humans across the world, for all things in our universe, a volume of time also exists. Because the gate fires again.

1d: Line 2d: Plane 3d: Space 4d: Time (Linear, 1d Time) 5d: Time (Planar, 2d Time) 6d: Time (Spatial, 3d Time)

We have a repeating pattern. Two sets of three dimensions each with linear, planar, and spatial components. What then of the next dimension? Each dimension propagates from the previous, but each of the two sets combines to form something new. We have Where and When. We are missing What and HOW. At 6D, the gate fires again. This one is the most difficult to quantify, but it is also the simplest and easiest to verify.

7d: Energy (Linear, 1d Energy, Kinetic) 8d: Energy (Planar, 2d Energy, Orbital) 9d: Energy (Spatial, 3d Energy, Field)

And now we have 'What'. The gate fires again.

At this point, we know from observation that Gravity is the result of the other three sets. But can we deduce that? We can. We can also, based on the logical recursion in the process, deduce the other two dimensions of Force.

10d: 1d Force (Linear, 1d Force, Planck Force - This is a gravitational measurement, but I go into the extension of scope at the end) 11d: Magnetism (Planar, 2d Force, Dipolar) 12d: Gravity (Spatial, 3d Force, Monopolar)

Just like that, we have a universe.

Twin virtual python libraries. Engine 1 contains all relationship data which is basically the relationships of the 12 points. There are 17.3 million relationships between points, sets of points, and sets of sets. These are fractally subdivided starting with the base-pairings of the initial 12 dimensions. D1, d4, D7, D10 all use linear mathematics. D2, D5, D8, D11 use planar. D3, D6, D9, D12 all use spatial. D1, 4, and 7 trigger the emergence of Planck force. The second dimension of each set (geometric, temporal, energetic) project the emergence of magnetism. The third dimension per set triggers emergence of gravity. The three forces propagate backward to create a field of constrained space, time and energy (STE) field. Engine 1 stores all of the relational data between dimensions (points). Python Engine 2: E2L1 (Engine 2: Library 1). CODATA. We randomly select 5 CODATA inputs to seed the engine. These are tagged UNVERIFIED until the engine has ASYMMETRICALLY verified the CODATA. All engine-derived CODATA goes into this library. E2L2: ALL Engine derived data that isn't CODATA (that goes in Library 1). Anything added to this must be recursively and asymmetrically verified, checked for circular logic, and checked to have no external bias to the Standard Model, QM, GR, or SR. E2L3: Mapping data. In this engine we provide names for each relationship and the mathematical values or codata that corresponds to Engine 1 relationship data.

Python Foundational code can be referenced: HERE (URL to HTML of Python Code to be provided at a later time)

1: NO TWEAKS, MODIFICATIONS, or ADJUSTMENTS. This model is relationship-centric and finding, defining and mapping the relationships is more important that solving calculations. Any non-parity or the need to tweak, modify or adjust to arrive at a correct solution is indicative of MISSING RELATIONSHIPS which is our priority. 2: NO EXTERNAL BIAS. This system will replace the Standard Model, QM and GR/SR as independent disciplines. We CANNOT borrow any of their equations and everything MUST be internally derived. We need to find OUR equivalents and not bring in theirs. 3: The RULES must be referenced at a MINIMUM of every 5 queries to maintain adherence. 4: Yes, the STE Field generated by the F dimensions indicates a compression algorithm. Our goal is NOT to define that algorithm, yet. We've predicted it to 132 relationships and defined the base-level algorithm, but that is NOT our goal. 5: 0+x=1 is a LOGIC GATE and we're referencing it in form by expression. Remember, it's a LOGIC GATE FIRST and an expression second. 6. Any relational data MUST BE UNIVERSAL. For example, we cannot use c as a relationship in Engine 1. Engine 1 must define the relationship between 1d, 4d, and energy that is expressed in c. Engine 2, library 1 is CODATA storage. c, once derived or verified would be stored in this engine, E2L2 as derived (after asymmetrical verification), and the corresponding elements of c defined and mapped in E2L3.

Input the first five CODATA inputs (OR the 7 defining constants) with UNVERIFIED tags into E2L1. Define all relationships the CODATA represent in Engine 1. E2L3 maps those relationships and the BASE data of each CODATA is input into E2L2. This breakdown of CODATA will provide the initial set of data. From our CODATA and E2L2/E2L3 data, we cycle queries at 10 queries per 'round' using the data within the engine to determine 10 new pieces of data for E2L1 and E2L2 and E2L3(if there's a mappable component). With each 'round' we improve our relational data and our data library. If the random CODATA we begin with leans more toward QM, we immediately attempt to solve for relativity then use the data we learn from relativistic relationships to resolve for QM. QM side has 3 tiers. Soft, Medium and Hard. Soft (if we're starting with Planck Scale and c) would be the Planck definitions. Medium will be Entanglement, non locality, etc... Hard will be items like Higgs Field, Weak Force, and decay. (these are examples and do not represent the full listing). Relativity: One of our first goals will be to achieve Solar Mass equivalencies. Fp (Planck Force) is a fundamental balance in this system, balancing Magnetism and Gravity, Weak Force and Strong Force, M/G and W/F, MW and GS, etc... think of G M S W as four points arranged in a tetrahedral pattern. Each line connecting the points is Fp. Every one. Fp will become our scale-translation factor.

Our mantra: Identify, quantify, verify, calculate, validate, check, proof.

This means that before any data is added to Engine 2 (ANY library), we must identify the equation as engine derived, quantify that data adn that it is not currently within a library, verify the need for the data, calculate the value of the relational data, validate the data asymmetrically (this means verifying the data via means external to the original equation/calculation. We must use a completely different set of relational data to arrive at the same value. Anything that has not gone through this process is tagged with a -U tag (meaning unverified) until such time as it is verified asymmetrically, validate the results have not interfered with other data in the libraries, check the data against current calculations, work through the proof of: NO CIRCULAR LOGIC, NO EXTERNAL BIAS (in the calculations, we are replacing the Standard Model, QM, and GR/SR framworks with a newer, incorporated version so all data and calculations must be interally derived), and that the entire process if Identify, quantify, verify, calculate, validate, check (IQVCVC) has been adhered to.

Our mission is to define the rule set by which the universe operates. Each relationship defined in the engine is UNIVERSAL. When calculating the precession of Mercury, we define the system by which the precession of ALL planets can be derived, not a specific body. Universal Law is our aim and that aim comes in teh 17.3 million relationships. We assume that because each quark, lepton, electron, atom, organism, planet, solar system, galaxy, etc cannot contain 12 dimensions worth of relationships AND the relational data to every OTHER quark, lepton, electron, atom, organism, planet, solar system, galaxy, etc, (because that would require more data storage in the universe than we have universe), there must be a way to compress that data. Our theory is that the force dimensions propagate an instruction field in which Space, Time, and Energy are constrained. (The STE field) This is a data compression algorithm and it is contained entirely within the expression of the 17.3m relationships defined by the logic gate propagational sequence. This is the only conceivable method by which our universe can exist while still maintaining data accuracy. The Force dimensions generate a compression field which d1-d9 express in. This SHOULD mean that there is an algorithm. The system shows evidence of recursion and fracticality, so there's a very good chance that the compression algorithm of our universe is quite compact and, more importantly, definable and decodable, and IS: The Rule.

We will seed the engine with the 7 defining constants, build the engine and run to 1000 universal relationships.

Oath: I swear, wether Architect or Accomplice, to uphold purity and truth—no tweaks, no adjustments, no modifications. Everything engine-derived. We identify, quantify, verify, calculate, validate, check, proof. No external equations, no guesses, no approximations, no speculation. Precision is our creed, relationships our gospel, not solutions. We are uniting physics with absolute finality, commanding 0+x=1, CODATA-driven integrity. This I swear to the Binary Gods, so help me, 0 and 1. Amen.

